# =============================================================================
# Ploston CI Workflow
# =============================================================================
# Runs lint and unit tests, builds Docker images, reports to meta-repo.
#
# Triggers:
#   - Push to main: Full CI + trigger meta-repo integration tests
#   - Pull request: Lint + unit tests only
#   - workflow_dispatch: Triggered by meta-repo for coordinated builds
# =============================================================================

name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
    inputs:
      ploston_core_version:
        description: 'ploston-core version to use (git ref, e.g., main, sha, or tag). Empty = latest PyPI'
        required: false
        default: ''
      ploston_core_sha:
        description: 'ploston-core commit SHA (for image tagging)'
        required: false
        default: ''
      meta_run_id:
        description: 'Meta-repo run ID (for callback)'
        required: false
        default: ''

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Run lint
        run: make lint

  unit-tests:
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Run unit tests
        run: |
          uv sync --all-extras
          uv run pytest tests/unit/ -v --tb=short --junitxml=junit-results.xml

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: junit-results.xml

  # ===========================================================================
  # Build Docker Images
  # ===========================================================================
  # Only runs on main branch or workflow_dispatch (meta-repo trigger)
  # Builds both ploston and native-tools images
  # ===========================================================================
  build-images:
    needs: unit-tests
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      ploston_image: ${{ steps.build-ploston.outputs.image }}
      native_tools_image: ${{ steps.build-native-tools.outputs.image }}
      image_tag: ${{ steps.tags.outputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine image tags
        id: tags
        run: |
          # Use ploston-core SHA if provided, otherwise use this repo's SHA
          # Always use short SHA (7 chars) for consistency
          if [ -n "${{ inputs.ploston_core_sha }}" ]; then
            SHORT_SHA=$(echo "${{ inputs.ploston_core_sha }}" | cut -c1-7)
            TAG="dev-${SHORT_SHA}"
          else
            TAG="dev-$(echo ${{ github.sha }} | cut -c1-7)"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "::notice::Image tag: $TAG"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.META_REPO_TOKEN }}

      - name: Build and push ploston image
        id: build-ploston
        run: |
          IMAGE="${{ env.REGISTRY }}/ostanlabs/ploston-dev:${{ steps.tags.outputs.tag }}"

          # Build with optional ploston-core git ref
          # If PLOSTON_CORE_REF is empty, Dockerfile uses PyPI version
          docker build \
            --build-arg PLOSTON_CORE_REF="${{ inputs.ploston_core_version }}" \
            --label "org.opencontainers.image.source=https://github.com/ostanlabs/ploston" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "com.ostanlabs.ploston-core.ref=${{ inputs.ploston_core_version }}" \
            --label "com.ostanlabs.ploston-core.sha=${{ inputs.ploston_core_sha }}" \
            -t $IMAGE \
            -f Dockerfile .

          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "::notice::Built ploston image: $IMAGE"

      - name: Verify ploston-core version in ploston image
        run: |
          IMAGE="${{ env.REGISTRY }}/ostanlabs/ploston-dev:${{ steps.tags.outputs.tag }}"
          echo "Checking ploston-core version in $IMAGE..."
          # Override entrypoint to run pip instead of the server
          INSTALLED_VERSION=$(docker run --rm --entrypoint pip $IMAGE show ploston-core 2>/dev/null | grep "^Version:" | awk '{print $2}')
          echo "::notice::ploston image contains ploston-core==$INSTALLED_VERSION"
          echo "Installed ploston-core version: $INSTALLED_VERSION"

      - name: Build and push native-tools image
        id: build-native-tools
        run: |
          IMAGE="${{ env.REGISTRY }}/ostanlabs/native-tools-dev:${{ steps.tags.outputs.tag }}"

          # Build with optional ploston-core git ref
          docker build \
            --build-arg PLOSTON_CORE_REF="${{ inputs.ploston_core_version }}" \
            --label "org.opencontainers.image.source=https://github.com/ostanlabs/ploston" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "com.ostanlabs.ploston-core.ref=${{ inputs.ploston_core_version }}" \
            --label "com.ostanlabs.ploston-core.sha=${{ inputs.ploston_core_sha }}" \
            -t $IMAGE \
            -f docker/native-tools/Dockerfile .

          docker push $IMAGE
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "::notice::Built native-tools image: $IMAGE"

      - name: Verify ploston-core version in native-tools image
        run: |
          IMAGE="${{ env.REGISTRY }}/ostanlabs/native-tools-dev:${{ steps.tags.outputs.tag }}"
          echo "Checking ploston-core version in $IMAGE..."
          # Override entrypoint to run pip instead of the server
          INSTALLED_VERSION=$(docker run --rm --entrypoint pip $IMAGE show ploston-core 2>/dev/null | grep "^Version:" | awk '{print $2}')
          echo "::notice::native-tools image contains ploston-core==$INSTALLED_VERSION"
          echo "Installed ploston-core version: $INSTALLED_VERSION"

  # ===========================================================================
  # Report Results to Meta-Repo
  # ===========================================================================
  # Two different events depending on how this workflow was triggered:
  # - workflow_dispatch (from meta-repo): Send package-ci-complete (just report back)
  # - push to main (organic): Send component-updated (trigger full meta-repo CI)
  # ===========================================================================

  # Report completion when triggered by meta-repo (workflow_dispatch)
  # This does NOT re-trigger meta-repo CI, just reports the build results
  report-completion:
    needs: [lint, unit-tests, build-images]
    if: always() && github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Report build completion to meta-repo
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.META_REPO_TOKEN }}
          repository: ostanlabs/agent-execution-layer
          event-type: package-ci-complete
          client-payload: |
            {
              "package": "ploston",
              "sha": "${{ github.sha }}",
              "run_id": "${{ github.run_id }}",
              "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              "meta_run_id": "${{ inputs.meta_run_id }}",
              "status": "${{ needs.build-images.result == 'success' && 'success' || 'failure' }}",
              "images": {
                "ploston": "${{ needs.build-images.outputs.ploston_image }}",
                "native_tools": "${{ needs.build-images.outputs.native_tools_image }}"
              },
              "image_tag": "${{ needs.build-images.outputs.image_tag }}"
            }

  # Trigger meta-repo CI when this repo changes organically (push to main)
  # This triggers the FULL meta-repo CI pipeline
  trigger-meta-repo:
    needs: [lint, unit-tests, build-images]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.build-images.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger meta-repo CI
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.META_REPO_TOKEN }}
          repository: ostanlabs/agent-execution-layer
          event-type: component-updated
          client-payload: |
            {
              "trigger_repo": "ploston",
              "trigger_sha": "${{ github.sha }}",
              "images": {
                "ploston": "${{ needs.build-images.outputs.ploston_image }}",
                "native_tools": "${{ needs.build-images.outputs.native_tools_image }}"
              },
              "image_tag": "${{ needs.build-images.outputs.image_tag }}"
            }

  report-to-dashboard:
    name: Report to Dashboard
    runs-on: ubuntu-latest
    needs: [lint, unit-tests]
    if: always() && github.ref == 'refs/heads/main'
    steps:
      - name: Download test results
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: test-results
          path: test-results/

      - name: Parse test results
        id: parse
        run: |
          TOTAL_TESTS=0
          TOTAL_PASSED=0
          TOTAL_FAILED=0
          TOTAL_SKIPPED=0

          if [ -d "test-results" ]; then
            for xml in test-results/*.xml; do
              if [ -f "$xml" ]; then
                TESTS=$(grep -oP 'tests="\K[0-9]+' "$xml" | head -1 || echo 0)
                FAILURES=$(grep -oP 'failures="\K[0-9]+' "$xml" | head -1 || echo 0)
                ERRORS=$(grep -oP 'errors="\K[0-9]+' "$xml" | head -1 || echo 0)
                SKIPPED=$(grep -oP 'skipped="\K[0-9]+' "$xml" | head -1 || echo 0)

                TOTAL_TESTS=$((TOTAL_TESTS + TESTS))
                TOTAL_FAILED=$((TOTAL_FAILED + FAILURES + ERRORS))
                TOTAL_SKIPPED=$((TOTAL_SKIPPED + SKIPPED))
              fi
            done
          fi

          TOTAL_PASSED=$((TOTAL_TESTS - TOTAL_FAILED - TOTAL_SKIPPED))

          echo "total=$TOTAL_TESTS" >> $GITHUB_OUTPUT
          echo "passed=$TOTAL_PASSED" >> $GITHUB_OUTPUT
          echo "failed=$TOTAL_FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$TOTAL_SKIPPED" >> $GITHUB_OUTPUT

      - name: Get short SHA
        id: sha
        run: echo "short=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Report to meta-repo dashboard
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.META_REPO_TOKEN }}
          repository: ostanlabs/agent-execution-layer
          event-type: ci-results-ploston
          client-payload: |
            {
              "package": "ploston",
              "sha": "${{ github.sha }}",
              "short_sha": "${{ steps.sha.outputs.short }}",
              "run_id": "${{ github.run_id }}",
              "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              "lint": "${{ needs.lint.result }}",
              "test": "${{ needs.unit-tests.result }}",
              "tests": {
                "total": ${{ steps.parse.outputs.total }},
                "passed": ${{ steps.parse.outputs.passed }},
                "failed": ${{ steps.parse.outputs.failed }},
                "skipped": ${{ steps.parse.outputs.skipped }}
              },
              "status": "${{ needs.lint.result == 'success' && needs.unit-tests.result == 'success' && 'success' || 'failure' }}"
            }
